{"meta":{"title":"乐闻技术笔记","subtitle":null,"description":"JAVA JavaScript python  乐闻的技术笔记","author":"乐闻","url":"http://blog.levenx.com","root":"/"},"pages":[{"title":"yourdiy","date":"2019-07-03T04:13:56.000Z","updated":"2019-07-03T04:13:56.331Z","comments":true,"path":"yourdiy/index.html","permalink":"http://blog.levenx.com/yourdiy/index.html","excerpt":"","text":""},{"title":"乐闻x技术笔记","date":"2019-07-03T03:32:46.000Z","updated":"2019-07-03T04:12:56.115Z","comments":true,"path":"about/index.html","permalink":"http://blog.levenx.com/about/index.html","excerpt":"","text":"乐闻x 明明听了很多大道理，却还是过不好一生"}],"posts":[{"title":"【设计模式】命令行模式","slug":"design-pattern/command-line","date":"2019-07-03T08:31:44.000Z","updated":"2019-07-03T07:33:11.674Z","comments":true,"path":"2019/07/03/design-pattern/command-line/","link":"","permalink":"http://blog.levenx.com/2019/07/03/design-pattern/command-line/","excerpt":"","text":"命令行模式 解决命令行的请求者和命令的实现之间的耦合关系 1.更方便对命令进行拓展2.对多个命令统一控制 将一个请求封装位一个对象，使发出请求的责任和执行请求的责任分割开。这样两者宅男通过命令对象进行沟通，这样方便将命令对象进行存储，传递，调用，增加与管理 抽象命令,具体命令角色实现者/接受者调用者/请求者","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.levenx.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.levenx.com/tags/设计模式/"},{"name":"命令行模式","slug":"命令行模式","permalink":"http://blog.levenx.com/tags/命令行模式/"}]},{"title":"【设计模式】代理模式","slug":"design-pattern/proxy","date":"2019-07-03T08:31:44.000Z","updated":"2019-07-03T07:41:49.896Z","comments":true,"path":"2019/07/03/design-pattern/proxy/","link":"","permalink":"http://blog.levenx.com/2019/07/03/design-pattern/proxy/","excerpt":"","text":"代理模式 偏重因自己无法完成或者自己无需关心，需要他人干涉时间流程，更多的是对对象的控制。注重对对象某一功能把控和辅助。他可以控制对象做某些事，重心事为了借用对象的功能完成某一流程，而非对象功能如何。 装饰者模式 偏重对原对象功能的扩展，扩展后的对象仍是对象本身。注重对对象的功能拓展，他不关系外界如何调用，只注重对对象功能的加强，装饰后哈市对象本身。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.levenx.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.levenx.com/tags/设计模式/"},{"name":"代理模式","slug":"代理模式","permalink":"http://blog.levenx.com/tags/代理模式/"}]},{"title":"【设计模式】策略模式","slug":"design-pattern/strategy","date":"2019-07-03T08:31:44.000Z","updated":"2019-07-03T07:26:32.676Z","comments":true,"path":"2019/07/03/design-pattern/strategy/","link":"","permalink":"http://blog.levenx.com/2019/07/03/design-pattern/strategy/","excerpt":"","text":"策略模式 &emsp;&emsp;定义了一系列算法，并将每一个算法封装起来，使得每个算法都可以相互替代，使算法本身和使用算法的客户端互相独立。 分离算法,选择实现 体现开闭原则，里氏替换原则 策略模式是一个扁平的结构，各个策略实现都是兄弟关系，实现了同一个接口或者继承了同一个抽象类，这样只要使用策略的客户端保持面向抽象编程，就可以动态的切换不同的策略实现以进行替换。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.levenx.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.levenx.com/tags/设计模式/"},{"name":"策略模式","slug":"策略模式","permalink":"http://blog.levenx.com/tags/策略模式/"}]},{"title":"springCloud学习笔记","slug":"java/springCloud/index","date":"2019-07-03T08:31:44.000Z","updated":"2019-07-03T07:49:01.687Z","comments":true,"path":"2019/07/03/java/springCloud/index/","link":"","permalink":"http://blog.levenx.com/2019/07/03/java/springCloud/index/","excerpt":"","text":"springCloud 服务注册与发现（Eureka） 服务消费者（ribbon + feign) 断路器（hystrix) 路由网关（zuul / gateway) 分布式配置中心 (config) 消息总线 (bus) 服务链路追踪 (sleuth)","categories":[{"name":"springCloud","slug":"springCloud","permalink":"http://blog.levenx.com/categories/springCloud/"}],"tags":[{"name":"springCloud","slug":"springCloud","permalink":"http://blog.levenx.com/tags/springCloud/"}]},{"title":"经典排序算法","slug":"algorithm/sort","date":"2019-07-03T08:31:44.000Z","updated":"2019-07-04T01:41:53.102Z","comments":true,"path":"2019/07/03/algorithm/sort/","link":"","permalink":"http://blog.levenx.com/2019/07/03/algorithm/sort/","excerpt":"","text":"springCloud 服务注册与发现（Eureka） 服务消费者（ribbon + feign) 断路器（hystrix) 路由网关（zuul / gateway) 分布式配置中心 (config) 消息总线 (bus) 服务链路追踪 (sleuth)","categories":[{"name":"常用算法","slug":"常用算法","permalink":"http://blog.levenx.com/categories/常用算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://blog.levenx.com/tags/排序算法/"}]},{"title":"","slug":"design-pattern/decorator","date":"2019-07-03T07:36:26.132Z","updated":"2019-07-03T07:36:26.132Z","comments":true,"path":"2019/07/03/design-pattern/decorator/","link":"","permalink":"http://blog.levenx.com/2019/07/03/design-pattern/decorator/","excerpt":"","text":"","categories":[],"tags":[]}]}
{"meta":{"title":"乐闻技术笔记","subtitle":null,"description":"JAVA JavaScript python  乐闻的技术笔记","author":"乐闻","url":"http://blog.levenx.com","root":"/"},"pages":[{"title":"yourdiy","date":"2019-07-03T04:13:56.000Z","updated":"2019-07-03T04:13:56.331Z","comments":true,"path":"yourdiy/index.html","permalink":"http://blog.levenx.com/yourdiy/index.html","excerpt":"","text":""},{"title":"乐闻x技术笔记","date":"2019-07-03T03:32:46.000Z","updated":"2019-07-03T04:12:56.115Z","comments":true,"path":"about/index.html","permalink":"http://blog.levenx.com/about/index.html","excerpt":"","text":"乐闻x 明明听了很多大道理，却还是过不好一生"}],"posts":[{"title":"经典排序算法","slug":"algorithm/sort","date":"2019-07-04T01:50:44.000Z","updated":"2019-07-04T03:40:24.983Z","comments":true,"path":"2019/07/04/algorithm/sort/","link":"","permalink":"http://blog.levenx.com/2019/07/04/algorithm/sort/","excerpt":"","text":"经典排序算法参考 算法总结 算法分类 冒泡排序（Bubble Sort） public static int[] bubbleSort(int[] array) { if (array.length == 0) return array; for (int i = 0; i < array.length; i++) for (int j = 0; j < array.length - 1 - i; j++) if (array[j + 1] < array[j]) { int temp = array[j + 1]; array[j + 1] = array[j]; array[j] = temp; } return array; 选择排序（Selection Sort） public static int[] selectionSort(int[] array) { if (array.length == 0) return array; for (int i = 0; i < array.length; i++) { int minIndex = i; for (int j = i; j < array.length; j++) { if (array[j] < array[minIndex]) //找到最小的数 minIndex = j; //将最小数的索引保存 } int temp = array[minIndex]; array[minIndex] = array[i]; array[i] = temp; } return array; } 工作原理: 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 插入排序（Insertion Sort） public static int[] insertionSort(int[] array) { if (array.length == 0) return array; int current; for (int i = 0; i < array.length - 1; i++) { current = array[i + 1]; int preIndex = i; while (preIndex >= 0 && current < array[preIndex]) { array[preIndex + 1] = array[preIndex]; preIndex--; } array[preIndex + 1] = current; } return array; } 一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 希尔排序（Shell Sort） public static int[] ShellSort(int[] array) { int len = array.length; int temp, gap = len / 2; while (gap > 0) { for (int i = gap; i < len; i++) { temp = array[i]; int preIndex = i - gap; while (preIndex >= 0 && array[preIndex] > temp) { array[preIndex + gap] = array[preIndex]; preIndex -= gap; } array[preIndex + gap] = temp; } gap /= 2; } return array; } 选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。 归并排序（Merge Sort） public static int[] MergeSort(int[] array) { if (array.length < 2) return array; int mid = array.length / 2; int[] left = Arrays.copyOfRange(array, 0, mid); int[] right = Arrays.copyOfRange(array, mid, array.length); return merge(MergeSort(left), MergeSort(right)); } public static int[] merge(int[] left, int[] right) { int[] result = new int[left.length + right.length]; for (int index = 0, i = 0, j = 0; index < result.length; index++) { if (i >= left.length) result[index] = right[j++]; else if (j >= right.length) result[index] = left[i++]; else if (left[i] > right[j]) result[index] = right[j++]; else result[index] = left[i++]; } return result; } 把长度为n的输入序列分成两个长度为n/2的子序列；对这两个子序列分别采用归并排序；将两个排序好的子序列合并成一个最终的排序序列。 快速排序（Quick Sort） public static int[] QuickSort(int[] array, int start, int end) { if (array.length < 1 || start < 0 || end >= array.length || start > end) return null; int smallIndex = partition(array, start, end); if (smallIndex > start) QuickSort(array, start, smallIndex - 1); if (smallIndex < end) QuickSort(array, smallIndex + 1, end); return array; } public static int partition(int[] array, int start, int end) { int pivot = (int) (start + Math.random() * (end - start + 1)); int smallIndex = start - 1; swap(array, pivot, end); for (int i = start; i","categories":[{"name":"常用算法","slug":"常用算法","permalink":"http://blog.levenx.com/categories/常用算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://blog.levenx.com/tags/排序算法/"}]},{"title":"【设计模式】命令行模式","slug":"design-pattern/command-line","date":"2019-07-03T08:31:44.000Z","updated":"2019-07-03T07:33:11.674Z","comments":true,"path":"2019/07/03/design-pattern/command-line/","link":"","permalink":"http://blog.levenx.com/2019/07/03/design-pattern/command-line/","excerpt":"","text":"命令行模式 解决命令行的请求者和命令的实现之间的耦合关系 1.更方便对命令进行拓展2.对多个命令统一控制 将一个请求封装位一个对象，使发出请求的责任和执行请求的责任分割开。这样两者宅男通过命令对象进行沟通，这样方便将命令对象进行存储，传递，调用，增加与管理 抽象命令,具体命令角色实现者/接受者调用者/请求者","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.levenx.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.levenx.com/tags/设计模式/"},{"name":"命令行模式","slug":"命令行模式","permalink":"http://blog.levenx.com/tags/命令行模式/"}]},{"title":"【设计模式】代理模式","slug":"design-pattern/proxy","date":"2019-07-03T08:31:44.000Z","updated":"2019-07-03T07:41:49.896Z","comments":true,"path":"2019/07/03/design-pattern/proxy/","link":"","permalink":"http://blog.levenx.com/2019/07/03/design-pattern/proxy/","excerpt":"","text":"代理模式 偏重因自己无法完成或者自己无需关心，需要他人干涉时间流程，更多的是对对象的控制。注重对对象某一功能把控和辅助。他可以控制对象做某些事，重心事为了借用对象的功能完成某一流程，而非对象功能如何。 装饰者模式 偏重对原对象功能的扩展，扩展后的对象仍是对象本身。注重对对象的功能拓展，他不关系外界如何调用，只注重对对象功能的加强，装饰后哈市对象本身。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.levenx.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.levenx.com/tags/设计模式/"},{"name":"代理模式","slug":"代理模式","permalink":"http://blog.levenx.com/tags/代理模式/"}]},{"title":"【设计模式】策略模式","slug":"design-pattern/strategy","date":"2019-07-03T08:31:44.000Z","updated":"2019-07-03T07:26:32.676Z","comments":true,"path":"2019/07/03/design-pattern/strategy/","link":"","permalink":"http://blog.levenx.com/2019/07/03/design-pattern/strategy/","excerpt":"","text":"策略模式 &emsp;&emsp;定义了一系列算法，并将每一个算法封装起来，使得每个算法都可以相互替代，使算法本身和使用算法的客户端互相独立。 分离算法,选择实现 体现开闭原则，里氏替换原则 策略模式是一个扁平的结构，各个策略实现都是兄弟关系，实现了同一个接口或者继承了同一个抽象类，这样只要使用策略的客户端保持面向抽象编程，就可以动态的切换不同的策略实现以进行替换。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.levenx.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.levenx.com/tags/设计模式/"},{"name":"策略模式","slug":"策略模式","permalink":"http://blog.levenx.com/tags/策略模式/"}]},{"title":"springCloud学习笔记","slug":"java/springCloud/index","date":"2019-07-03T08:31:44.000Z","updated":"2019-07-03T07:49:01.687Z","comments":true,"path":"2019/07/03/java/springCloud/index/","link":"","permalink":"http://blog.levenx.com/2019/07/03/java/springCloud/index/","excerpt":"","text":"springCloud 服务注册与发现（Eureka） 服务消费者（ribbon + feign) 断路器（hystrix) 路由网关（zuul / gateway) 分布式配置中心 (config) 消息总线 (bus) 服务链路追踪 (sleuth)","categories":[{"name":"springCloud","slug":"springCloud","permalink":"http://blog.levenx.com/categories/springCloud/"}],"tags":[{"name":"springCloud","slug":"springCloud","permalink":"http://blog.levenx.com/tags/springCloud/"}]},{"title":"","slug":"design-pattern/decorator","date":"2019-07-03T07:36:26.132Z","updated":"2019-07-03T07:36:26.132Z","comments":true,"path":"2019/07/03/design-pattern/decorator/","link":"","permalink":"http://blog.levenx.com/2019/07/03/design-pattern/decorator/","excerpt":"","text":"","categories":[],"tags":[]}]}